SUBTTL	STRING FUNCTIONS.
;
; THE STR$ FUNCTION TAKES A NUMBER AND GIVES A STRING
; WITH THE CHARACTERS THE OUTPUT OF THE NUMBER
; WOULD HAVE GIVEN.
;
STR:	JSR	CHKNUM		;ARG HAS TO BE NUMERIC.
	LDYI	0
	JSR	FOUTC		;DO ITS OUTPUT.
	PLA
	PLA
TIMSTR: LDWDI	LOFBUF
	BEQA	STRLIT		;SCAN IT AND TURN IT INTO A STRING.
;
; "STRINI" GET STRING SPACE FOR THE CREATION OF A STRING AND
; CREATES A DESCRIPTOR FOR IT IN "DSCTMP".
;
STRINI: LDXY	FACMO		;GET FACMO TO STORE IN DSCPNT.
	STXY	DSCPNT		;RETAIN THE DESCRIPTOR POINTER.
STRSPA: JSR	GETSPA		;GET STRING SPACE.
	STXY	DSCTMP+1	;SAVE LOCATION.
	STA	DSCTMP		;SAVE LENGTH.
	RTS			;ALL DONE.
;
; "STRLT2" TAKES THE STRING LITERAL WHOSE FIRST CHARACTER
; IS POINTED TO BY [Y,A] AND BUILDS A DESCRIPTOR FOR IT.
; THE DESCRIPTOR IS INITIALLY BUILT IN "DSCTMP", BUT "PUTNEW"
; TRANSFERS IT INTO A TEMPORARY AND LEAVES A POINTER
; AT THE TEMPORARY IN FACMO&LO. THE CHARACTERS OTHER THAN
; ZERO THAT TERMINATE THE STRING SHOULD BE SET UP IN "CHARAC"
; AND "ENDCHR". IF THE TERMINATOR IS A QUOTE, THE QUOTE IS SKIPPED
; OVER. LEADING QUOTES SHOULD BE SKIPPED BEFORE JSR. ON RETURN
; THE CHARACTER AFTER THE STRING LITERAL IS POINTED TO
; BY [STRNG2].
;
STRLIT: LDXI	34		;ASSUME STRING ENDS ON QUOTE.
	STX	CHARAC
	STX	ENDCHR
STRLT2: STWD	STRNG1		;SAVE POINTER TO STRING.
	STWD	DSCTMP+1	;IN CASE NO STRCPY.
	LDYI	255		;INITIALIZE CHARACTER COUNT.
STRGET: INY
	LDADY	STRNG1		;GET CHARACTER.
	BEQ	STRFI1		;IF ZERO.
	CMP	CHARAC		;THIS TERMINATOR?
	BEQ	STRFIN		;YES.
	CMP	ENDCHR
	BNE	STRGET		;LOOK FURTHER.
STRFIN: CMPI	34		;QUOTE?
	BEQ	STRFI2
STRFI1: CLC			;NO, BACK UP.
STRFI2: STY	DSCTMP		;RETAIN COUNT.
	TYA
	ADC	STRNG1		;WISHING TO SET [TXTPTR].
	STA	STRNG2
	LDX	STRNG1+1
	BCC	STRST2
	INX
STRST2: STX	STRNG2+1
	LDA	STRNG1+1	;IF PAGE 0, COPY SINCE IT IS EITHER
				;A STRING CONSTANT IN BUF OR A STR$
				;RESULT IN LOFBUF
IFN	BUFPAG,<
	BEQ	STRCP
	CMPI	BUFPAG>
	BNE	PUTNEW
STRCP:	TYA
	JSR	STRINI
	LDXY	STRNG1
	JSR	MOVSTR		;MOVE STRING.
;
; SOME STRING FUNCTION IS RETURNING A RESULT IN DSCTMP.
; SETUP A TEMP DESCRIPTOR WITH DSCTMP IN IT.
; PUT A POINTER TO THE DESCRIPTOR IN FACMO&LO AND FLAG THE
; RESULT AS TYPE STRING.
;
PUTNEW: LDX	TEMPPT		;POINTER TO FIRST FREE TEMP.
	CPXI	TEMPST+STRSIZ*NUMTMP
	BNE	PUTNW1
	LDXI	ERRST		;STRING TEMPORARY ERROR.
ERRGO2: JMP	ERROR		;GO TELL HIM.
PUTNW1: LDA	DSCTMP
	STA	0,X
	LDA	DSCTMP+1
	STA	1,X
	LDA	DSCTMP+2
	STA	2,X
	LDYI	0
	STXY	FACMO
	STY	FACOV
	DEY
	STY	VALTYP		;TYPE IS "STRING".
	STX	LASTPT		;SET POINTER TO LAST-USED TEMP.
	INX
	INX
	INX			;POINT FURTHER.
	STX	TEMPPT		;SAVE POINTER TO NEXT TEMP IF ANY.
	RTS			;ALL DONE.

;
; GETSPA - GET SPACE FOR CHARACTER STRING.
; MAY FORCE GARBAGE COLLECTION.
;
; # OF CHARACTERS (BYTES) IN ACCA.
; RETURNS WITH POINTER IN [Y,X]. OTHERWISE (IF CAN'T GET
; SPACE) BLOWS OFF TO "OUT OF STRING SPACE" TYPE ERROR.
; ALSO PRESERVES [ACCA] AND SETS [FRESPC]=[Y,X]=PNTR AT SPACE.
;
GETSPA: LSR	GARBFL		;SIGNAL NO GARBAGE COLLECTION YET.
TRYAG2: PHA			;SAVE FOR LATER.
	EORI	255
	SEC			;ADD ONE TO COMPLETE NEGATION.
	ADC	FRETOP
	LDY	FRETOP+1
	BCS	TRYAG3
	DEY
TRYAG3: CPY	STREND+1	;COMPARE HIGH ORDERS.
	BCC	GARBAG		;MAKE ROOM FOR MORE.
	BNE	STRFRE		;SAVE NEW FRETOP.
	CMP	STREND		;COMPARE LOW ORDERS.
	BCC	GARBAG		;CLEAN UP.
STRFRE: STWD	FRETOP		;SAVE NEW [FRETOP].
	STWD	FRESPC		;PUT IT THERE OLD MAN.
	TAX			;PRESERVE A IN X.
	PLA			;GET COUNT BACK IN ACCA.
	RTS			;ALL DONE.
GARBAG: LDXI	ERROM		;"OUT OF STRING SPACE"
	LDA	GARBFL
	BMI	ERRGO2
	JSR	GARBA2
	LDAI	128
	STA	GARBFL
	PLA			;GET BACK STRING LENGTH.
	BNE	TRYAG2		;ALWAYS BRANCHES.
GARBA2:				;START FROM TOP DOWN.
IFE	REALIO!DISKO,<
	LDAI	7		;TYPE "BELL".
	JSR	OUTDO>
	LDX	MEMSIZ
	LDA	MEMSIZ+1
FNDVAR: STX	FRETOP		;LIKE SO.
	STA	FRETOP+1
	LDYI	0
	STY	GRBPNT+1
	STY	GRBPNT		;BOTH BYTES SET TO ZERO (FIX BUG)
	LDWX	STREND
	STWX	GRBTOP
	LDWXI	TEMPST
	STWX	INDEX1
TVAR:	CMP	TEMPPT		;DONE WITH TEMPS?
	BEQ	SVARS		;YEP.
	JSR	DVAR
	BEQ	TVAR		;LOOP.
SVARS:	LDAI	6+ADDPRC
	STA	FOUR6
	LDWX	VARTAB		;GET START OF SIMPLE VARIABLES.
	STWX	INDEX1
SVAR:	CPX	ARYTAB+1	;DONE WITH SIMPLE VARIABLES?
	BNE	SVARGO		;NO.
	CMP	ARYTAB
	BEQ	ARYVAR		;YEP.
SVARGO: JSR	DVARS		;DO IT , AGAIN.
	BEQ	SVAR		;LOOP.
ARYVAR: STWX	ARYPNT		;SAVE FOR ADDITION.
	LDAI	STRSIZ
	STA	FOUR6
ARYVA2: LDWX	ARYPNT		;GET THE POINTER TO VARIABLE.
ARYVA3: CPX	STREND+1	;DONE WITH ARRAYS?
	BNE	ARYVGO		;NO.
	CMP	STREND
	JEQ	GRBPAS		;YES, GO FINISH UP.
ARYVGO: STWX	INDEX1
	LDYI	1-ADDPRC
IFN	ADDPRC,<
	LDADY	INDEX1
	TAX
	INY>
	LDADY	INDEX1
	PHP
	INY
	LDADY	INDEX1
	ADC	ARYPNT
	STA	ARYPNT		;FORM POINTER TO NEXT ARRAY VAR.
	INY
	LDADY	INDEX1
	ADC	ARYPNT+1
	STA	ARYPNT+1
	PLP
	BPL	ARYVA2
IFN	ADDPRC,<
	TXA
	BMI	ARYVA2>
	INY
	LDADY	INDEX1
	LDYI	0		;RESET INDEX Y.
	ASL	A,
	ADCI	5		;CARRY IS OFF AND OFF AFTER ADD.
	ADC	INDEX1
	STA	INDEX1
	BCC	ARYGET
	INC	INDEX1+1
ARYGET: LDX	INDEX1+1
ARYSTR: CPX	ARYPNT+1	;END OF THE ARRAY?
	BNE	GOGO
	CMP	ARYPNT
	BEQ	ARYVA3		;YES.
GOGO:	JSR	DVAR
	BEQ	ARYSTR		;CYCLE.
DVARS:
IFN	INTPRC,<
	LDADY	INDEX1
	BMI	DVARTS>
	INY
	LDADY	INDEX1
	BPL	DVARTS
	INY
DVAR:	LDADY	INDEX1		;IS LENGTH=0?
	BEQ	DVARTS		;YES, RETURN.
	INY
	LDADY	INDEX1		;GET LOW(ADR).
	TAX
	INY
	LDADY	INDEX1
	CMP	FRETOP+1	;COMPARE HIGHS.
	BCC	DVAR2		;IF THIS STRING'S PNTR .GE. [FRETOP]
	BNE	DVARTS		;NO NEED TO MESS WITH IT FURTHER.
	CPX	FRETOP		;COMPARE LOWS.
	BCS	DVARTS
DVAR2:	CMP	GRBTOP+1
	BCC	DVARTS		;IF THIS STRING IS BELOW PREVIOUS,
				;FORGET IT.
	BNE	DVAR3
	CPX	GRBTOP		;COMPARE LOW ORDERS.
	BCC	DVARTS		;[X,A] .LE. [GRBTOP].
DVAR3:	STX	GRBTOP
	STA	GRBTOP+1
	LDWX	INDEX1
	STWX	GRBPNT
	LDA	FOUR6
	STA	SIZE
DVARTS: LDA	FOUR6
	CLC
	ADC	INDEX1
	STA	INDEX1
	BCC	GRBRTS
	INC	INDEX1+1
GRBRTS: LDX	INDEX1+1
	LDYI	0
	RTS			;DONE.
;
; HERE WHEN MADE ONE COMPLETE PASS THROUGH STRING VARIABLES.
;
GRBPAS: LDA	GRBPNT+1	;VARIABLE POINTER.
	ORA	GRBPNT
	BEQ	GRBRTS		;ALL DONE.
	LDA	SIZE
	ANDI	4		;LEAVES C OFF.
	LSR	A,
	TAY
	STA	SIZE
	LDADY	GRBPNT
				;NOTE: GRBTOP=LOWTR SO NO NEED TO SET LOWTR.
	ADC	LOWTR
	STA	HIGHTR
	LDA	LOWTR+1
	ADCI	0
	STA	HIGHTR+1
	LDWX	FRETOP
	STWX	HIGHDS		;WHERE IT ALL GOES.
	JSR	BLTUC
	LDY	SIZE
	INY
	LDA	HIGHDS		;GET POSITION OF START OF RESULT.
	STADY	GRBPNT
	TAX
	INC	HIGHDS+1
	LDA	HIGHDS+1
	INY
	STADY	GRBPNT		;CHANGE ADDR OF STRING IN VAR.
	JMP	FNDVAR		;GO TO FNDVAR WITH SOMETHING FOR
				;[FRETOP].
;
; THE FOLLOWING ROUTINE CONCATENATES TWO STRINGS.
; THE FAC CONTAINS THE FIRST ONE AT THIS POINT.
; [TXTPTR] POINTS TO THE + SIGN.
;
CAT:	LDA	FACLO		;PSH HIGH ORDER ONTO STACK.
	PHA
	LDA	FACMO		;AND THE LOW.
	PHA
	JSR	EVAL		;CAN COME BACK HERE SINCE
				;OPERATOR IS KNOWN.
	JSR	CHKSTR		;RESULT MUST BE STRING.
	PLA
	STA	STRNG1		;GET HIGH ORDER OF OLD DESC.
	PLA
	STA	STRNG1+1
	LDYI	0
	LDADY	STRNG1		;GET LENGTH OF OLD STRING.
	CLC
	ADCDY	FACMO
	BCC	SIZEOK		;RESULT IS LESS THAN 256.
	LDXI	ERRLS		;ERROR "LONG STRING".
	JMP	ERROR
SIZEOK: JSR	STRINI		;INITIALIZE STRING.
	JSR	MOVINS		;MOVE IT.
	LDWD	DSCPNT		;GET POINTER TO SECOND.
	JSR	FRETMP		;FREE IT.
	JSR	MOVDO
	LDWD	STRNG1
	JSR	FRETMP
	JSR	PUTNEW
	JMP	TSTOP		;"CAT" REENTERS FORM EVAL AT TSTOP.

MOVINS: LDYI	0		;GET ADDR OF STRING.
	LDADY	STRNG1
	PHA
	INY
	LDADY	STRNG1
	TAX
	INY
	LDADY	STRNG1
	TAY
	PLA
MOVSTR: STXY	INDEX
MOVDO:	TAY
	BEQ	MVDONE
	PHA
MOVLP:	DEY
	LDADY	INDEX
	STADY	FRESPC
QMOVE:	TYA
	BNE	MOVLP
	PLA
MVDONE: CLC
	ADC	FRESPC
	STA	FRESPC
	BCC	MVSTRT
	INC	FRESPC+1
MVSTRT: RTS
;
; "FRETMP" IS PASSED A STRING DESCRIPTOR PNTR IN [Y,A].
; A CHECK IS MADE TO SEE IF THE STRING DESCRIPTOR POINTS TO THE LAST
; TEMPORARY DESCRIPTOR ALLOCATED BY PUTNEW.
; IF SO, THE TEMPORARY IS FREED UP BY THE UPDATING OF [TEMPPT].
; IF A TEMP IS FREED UP, A FURTHER CHECK SEES IF THE STRING DATA THAT
; THAT STRING TEMP PNT'D TO IS THE LOWEST PART OF STRING SPACE IN USE.
; IF SO, [FRETOP] IS UPDATED TO REFLECT THE FACT THE FACT THAT THE SPACE
; IS NO LONGER IN USE.
; THE ADDR OF THE ACTUAL STRING IS RETURNED IN [Y,X] AND
; ITS LENGTH IN ACCA.
;
FRESTR: JSR	CHKSTR		;MAKE SURE ITS A STRING.
FREFAC: LDWD	FACMO		;FREE UP STR PNT'D TO BY FAC.
FRETMP: STWD	INDEX		;GET LENGTH FOR LATER.
	JSR	FRETMS		;FREE UP THE TEMPORARY DESC.
	PHP			;SAVE CODES.
	LDYI	0		;PREP TO GET STUFF.
	LDADY	INDEX		;GET COUNT AND
	PHA			;SAVE IT.
	INY
	LDADY	INDEX
	TAX			;SAVE LOW ORDER.
	INY
	LDADY	INDEX
	TAY			;SAVE HIGH ORDER.
	PLA
	PLP			;RETURN STATUS.
	BNE	FRETRT
	CPY	FRETOP+1	;STRING IS LAST ONE IN?
	BNE	FRETRT
	CPX	FRETOP
	BNE	FRETRT
	PHA
	CLC
	ADC	FRETOP
	STA	FRETOP
	BCC	FREPLA
	INC	FRETOP+1
FREPLA: PLA			;GET COUNT BACK.
FRETRT: STXY	INDEX		;SAVE FOR LATER USE.
	RTS
FRETMS: CPY	LASTPT+1	;LAST ENTRY TO TEMP? 
	BNE	FRERTS
	CMP	LASTPT
	BNE	FRERTS
	STA	TEMPPT
	SBCI	STRSIZ		;POINT TO LAST ONE.
	STA	LASTPT		;UPDATE TEMP PNTR.
	LDYI	0		;ALSO CLEARS ZFLG SO WE DO REST OF FRETMP.
FRERTS: RTS			;ALL DONE.
;
; CHR$(#) CREATES A STRING WHICH CONTAINS AS ITS ONLY
; CHARACTER THE ASCII EQUIVALENT OF THE INTEGER ARGUMENT (#)
; WHICH MUST BE .LT. 255.
;
CHR:	JSR	CONINT		;GET INTEGER IN RANGE.
	TXA
	PHA
	LDAI	1		;ONE-CHARACTER STRING.
	JSR	STRSPA		;GET SPACE FOR STRING.
	PLA
	LDYI	0
	STADY	DSCTMP+1
	PLA			;GET RID OF "CHKNUM" RETURN ADDR.
	PLA
RLZRET: JMP	PUTNEW		;SETUP FAC TO POINT TO DESC.
;
; THE FOLLOWING IS THE LEFT$($,#) FUNCTION.
; IT TAKES THE LEFTMOST # CHARACTERS OF THE STRING.
; IF # .GT. THE LEN OF THE STRING, IT RETURNS THE WHOLE STRING.
;
LEFT:	JSR	PREAM		;TEST PARAMETERS.
	CMPDY	DSCPNT
	TYA
RLEFT:	BCC	RLEFT1
	LDADY	DSCPNT
	TAX			;PUT LENGTH INTO X.
	TYA			;ZERO A, THE OFFSET.
RLEFT1: PHA			;SAVE OFFSET.
RLEFT2: TXA
RLEFT3: PHA			;SAVE LENGTH.
	JSR	STRSPA		;GET SPACE.
	LDWD	DSCPNT
	JSR	FRETMP
	PLA
	TAY
	PLA
	CLC
	ADC	INDEX		;COMPUTE WHERE TO COPY.
	STA	INDEX
	BCC	PULMOR
	INC	INDEX+1
PULMOR: TYA
	JSR	MOVDO		;GO MOVE IT.
	JMP	PUTNEW
RIGHT:	JSR	PREAM
	CLC			;[LENGTH DES'D]-[LENGTH]-1.
	SBCDY	DSCPNT
	EORI	255		;NEGATE.
	JMP	RLEFT
;
; MID ($,#) RETURNS STRING WITH CHARS FROM # POSITION
; ONWARD. IF # .GT. LEN ($) THEN RETURN NULL STRING.
; MID ($,#,#) RETURNS STRING WITH CHARACTERS FROM
; # POSITION FOR #2 CHARACTERS. IF #2 GOES PAST END OF STRING
; RETURN AS MUCH AS POSSIBLE.
;
MID:	LDAI	255		;DEFAULT.
	STA	FACLO		;SAVE FOR LATER COMPARE.
	JSR	CHRGOT		;GET CURRENT CHARACTER.
	CMPI	41		;IS IT A RIGHT PAREN )?
	BEQ	MID2		;NO THIRD PARAM.
	JSR	CHKCOM		;MUST HAVE COMMA.
	JSR	GETBYT		;GET THE LENGTH INTO "FACLO".
MID2:	JSR	PREAM		;CHECK IT OUT.
	BEQ	GOFUC		;THERE IS NO POSTION 0
	DEX			;COMPUTE OFFSET.
	TXA
	PHA			;PRSERVE AWHILE.
	CLC
	LDXI	0
	SBCDY	DSCPNT		;GET LENGTH OF WHAT'S LEFT.
	BCS	RLEFT2		;GIVE NULL STRING.
	EORI	255		;IN SUB C WAS 0 SO JUST COMPLEMENT.
	CMP	FACLO		;GREATER THAN WHAT'S DESIRED?
	BCC	RLEFT3		;NO, COPY THAT MUCH.
	LDA	FACLO		;GET LENGTH OF WHAT'S DESIRED.
	BCS	RLEFT3		;COPY IT.

;
; USED BY RIGHT$, LEFT$, MID$ FOR PARAMETER CHECKING AND SETUP.
;
PREAM:	JSR	CHKCLS		;PARAM LIST SHOULD END.
	PLA			;GET THE RETURN ADDRESS INTO
	TAY			;[JMPER+1,Y]
	PLA
	STA	JMPER+1
	PLA			;GET RID OF FINGO'S JSR RET ADDR.
	PLA
	PLA			;GET LENGTH.
	TAX
	PULWD	DSCPNT
	LDA	JMPER+1		;PUT RETURN ADDRESS BACK ON
	PHA
	TYA
	PHA
	LDYI	0
	TXA
	RTS
;
; THE FUNCTION LEN($) RETURNS THE LENGTH OF THE STRING
; PASSED AS AN ARGUMENT.
;
LEN:	JSR	LEN1
	JMP	SNGFLT
LEN1:	JSR	FRESTR		;FREE UP STRING.
	LDXI	0
	STX	VALTYP		;FORCE NUMERIC.
	TAY			;SET CODES ON LENGTH.
	RTS			;DONE.
;
; THE FOLLOWING IS THE ASC($) FUNCTION. IT RETURNS
; AN INTEGER WHICH IS THE DECIMAL ASCII EQUIVALENT.
;
ASC:	JSR	LEN1
	BEQ	GOFUC		;NULL STRING, BAD ARG.
	LDYI	0
	LDADY	INDEX1		;GET CHARACTER.
	TAY
	JMP	SNGFLT
GOFUC:	JMP	FCERR		;YES.

GTBYTC: JSR	CHRGET
GETBYT: JSR	FRMNUM		;READ FORMULA INTO FAC.
CONINT: JSR	POSINT		;CONVERT THE FAC TO A SINGLE BYTE INT.
	LDX	FACMO
	BNE	GOFUC		;RESULT MUST BE .LE. 255.
	LDX	FACLO
CHRGO2: JMP	CHRGOT		;SET CONDITION CODES ON TERMINATOR.
;
; THE "VAL" FUNCTION TAKES A STRING AND TURNS IT INTO
; A NUMBER BY INTERPRETING THE ASCII DIGITS ETCQ
; EXCEPT FOR THE PROBLEM THAT A TERMINATOR MUST BE SUPPLIED
; BY REPLACING THE CHARACTER BEYOND THE STRING, VAL IS MERELY
; A CALL TO FLOATING POINT INPUT ("FIN").
;
VAL:	JSR	LEN1		;DO SETUP. SET RESULT=NUMERIC.
	JEQ	ZEROFC		;ZERO THE FAC ON A NULL STRING
	LDXY	TXTPTR
	STXY	STRNG2		;SAVE FOR LATER.
	LDX	INDEX1
	STX	TXTPTR
	CLC
	ADC	INDEX1
	STA	INDEX2
	LDX	INDEX1+1
	STX	TXTPTR+1
	BCC	VAL2		;NO CARRY, NO INC.
	INX
VAL2:	STX	INDEX2+1
	LDYI	0
	LDADY	INDEX2		;PRESERVE CHARACTER.
	PHA
	LDAI	0		;SET A TERMINATOR.
	STADY	INDEX2
	JSR	CHRGOT		;GET CHARACTER PNT'D TO AND SET FLAGS.
	JSR	FIN
	PLA			;GET PRES'D CHARACTER.
	LDYI	0
	STADY	INDEX2		;STUFF IT BACK.
ST2TXT: LDXY	STRNG2
	STXY	TXTPTR
VALRTS: RTS			;ALL DONE WITH STRINGS.
PAGE
