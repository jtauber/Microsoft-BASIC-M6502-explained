SUBTTL	ERROR HANDLER, READY, TERMINAL INPUT, COMPACTIFY, NEW, REINIT.
OMERR:	LDXI	ERROM
ERROR:
IFN	REALIO,<
	LSR	CNTWFL>		;FORCE OUTPUT.
IFN	EXTIO,<
	LDA	CHANNL		;CLOSE NON-TERMINAL CHANNEL.
	BEQ	ERRCRD
	JSR	CQCCHN		;CLOSE IT.
	LDAI	0
	STA	CHANNL>
ERRCRD: JSR	CRDO		;OUTPUT CRLF.
	JSR	OUTQST		;PRINT A QUESTION MARK
IFE LNGERR,<
	LDA	ERRTAB,X,	;GET FIRST CHR OF ERR MSG.
	JSR	OUTDO		;OUTPUT IT.
	LDA	ERRTAB+1,X,	;GET SECOND CHR.
	JSR	OUTDO>		;OUTPUT IT.
IFN LNGERR,<
GETERR: LDA	ERRTAB,X
	PHA
	ANDI	127		;GET RID OF HIGH BIT.
	JSR	OUTDO		;OUTPUT IT.
	INX
	PLA			;LAST CHAR OF MESSAGE?
	BPL	GETERR>		;NO. GO GET NEXT AND OUTPUT IT.
TYPERR: JSR	STKINI		;RESET THE STACK AND FLAGS.
	LDWDI	ERR		;GET PNTR TO " ERROR".
ERRFIN: JSR	STROUT		;OUTPUT IT.
	LDY	CURLIN+1
	INY			;WAS NUMBER 64000?
	BEQ	READY		;YES, DON'T TYPE LINE NUMBER.
	JSR	INPRT
READY:
IFN	REALIO,<
	LSR	CNTWFL>		;TURN OUTPUT BACK ON IF SUPRESSED
	LDWDI	REDDY		;SAY "OK".
IFN	REALIO-3,<
	JSR	RDYJSR>		;OR GO TO INIT IF INIT ERROR.
IFE	REALIO-3,<
	JSR	STROUT>		;NO INIT ERRORS POSSIBLE.
MAIN:	JSR	INLIN		;GET A LINE FROM TERMINAL.
	STXY	TXTPTR
	JSR	CHRGET
	TAX			;SET ZERO FLAG BASED ON [A]
				;THIS DISTINGUISHES ":" AND 0
	BEQ	MAIN		;IF BLANK LINE, GET ANOTHER.
	LDXI	255		;SET DIRECT LINE NUMBER.
	STX	CURLIN+1
	BCC	MAIN1		;IS A LINE NUMBER. NOT DIRECT.
	JSR	CRUNCH		;COMPACTIFY.
	JMP	GONE		;EXECUTE IT.
MAIN1:	JSR	LINGET		;READ LINE NUMBER INTO "LINNUM".
	JSR	CRUNCH
	STY	COUNT		;RETAIN CHARACTER COUNT.
	JSR	FNDLIN
	BCC	NODEL		;NO MATCH, SO DON'T DELETE.
	LDYI	1
	LDADY	LOWTR
	STA	INDEX1+1
	LDA	VARTAB
	STA	INDEX1
	LDA	LOWTR+1		;SET TRANSFER TO.
	STA	INDEX2+1
	LDA	LOWTR
	DEY
	SBCDY	LOWTR		;COMPUTE NEGATIVE LENGTH.
	CLC
	ADC	VARTAB		;COMPUTE NEW VARTAB.
	STA	VARTAB
	STA	INDEX2		;SET LOW OF TRANS TO.
	LDA	VARTAB+1
	ADCI	255
	STA	VARTAB+1	;COMPUTE HIGH OF VARTAB.
	SBC	LOWTR+1		;COMPUTE NUMBER OF BLOCKS TO MOVE.
	TAX
	SEC
	LDA	LOWTR
	SBC	VARTAB		;COMPUTE OFFSET.
	TAY
	BCS	QDECT1		;IF VARTAB.LE.LOWTR,
	INX			;DECR DUE TO CARRY, AND
	DEC	INDEX2+1	;DECREMENT STORE SO CARRY WORKS.
QDECT1: CLC
	ADC	INDEX1
	BCC	MLOOP
	DEC	INDEX1+1
	CLC			;FOR LATER ADCQ
MLOOP:	LDADY	INDEX1
	STADY	INDEX2
	INY
	BNE	MLOOP		;BLOCK DONE?
	INC	INDEX1+1
	INC	INDEX2+1
	DEX
	BNE	MLOOP		;DO ANOTHER BLOCK. ALWAYS.
NODEL:	JSR	RUNC		;RESET ALL VARIABLE INFO SO GARBAGE
				;COLLECTION CAUSED BY REASON WILL WORK
	JSR	LNKPRG		;FIX UP THE LINKS
	LDA	BUF		;SEE IF ANYTHNG THERE
	BEQ	MAIN
	CLC
	LDA	VARTAB
	STA	HIGHTR		;SETUP HIGHTR.
	ADC	COUNT		;ADD LENGTH OF LINE TO INSERT.
	STA	HIGHDS		;THIS GIVES DEST ADDR.
	LDY	VARTAB+1
	STY	HIGHTR+1	;SAME FOR HIGH ORDERS.
	BCC	NODELC
	INY
NODELC: STY	HIGHDS+1
	JSR	BLTU
IFN	BUFPAG,<
	LDWD	LINNUM		;POSITION THE BINARY LINE NUMBER
	STWD	BUF-2>		;IN FRONT OF BUF
	LDWD	STREND
	STWD	VARTAB
	LDY	COUNT
	DEY
STOLOP: LDA	BUF-4,Y
	STADY	LOWTR
	DEY
	BPL	STOLOP
FINI:	JSR	RUNC		;DO CLEAR & SET UP STACK.
				;AND SET [TXTPTR] TO [TXTTAB]-1.
	JSR	LNKPRG		;FIX UP PROGRAM LINKS
	JMP	MAIN
LNKPRG: LDWD	TXTTAB		;SET [INDEX] TO [TXTTAB].
	STWD	INDEX
	CLC
;
; CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES
; UP ALL THE LINKS. THE END OF EACH LINE IS FOUND
; BY SEARCHING FOR THE ZERO AT THE END.
; THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM.
;
CHEAD:	LDYI	1
	LDADY	INDEX		;ARRIVED AT DOUBLE ZEROES?
	BEQ	LNKRTS
	LDYI	4
CZLOOP: INY			;THERE IS AT LEAST ONE BYTE.
	LDADY	INDEX
	BNE	CZLOOP		;NO, CONTINUE SEARCHING.
	INY			;GO ONE BEYOND.
	TYA
	ADC	INDEX
	TAX
	LDYI	0
	STADY	INDEX
	LDA	INDEX+1
	ADCI	0
	INY
	STADY	INDEX
	STX	INDEX
	STA	INDEX+1
	BCCA	CHEAD		;ALWAYS BRANCHES.
LNKRTS: RTS
;
; THIS IS THE LINE INPUT ROUTINE.
; IT READS CHARACTERS INTO BUF USING BACKARROW (UNDERSCORE, OR
; SHIFT O) AS THE DELETE CHARACTER AND @ AS THE 
; LINE DELETE CHARACTER. IF MORE THAN BUFLEN CHARACTERS
; ARE TYPED, NO ECHOING IS DONE UNTIL A BACKARROW OR @ OR CR
; IS TYPED. CONTROL-G WILL BE TYPED FOR EACH EXTRA CHARACTER.
; THE ROUTINE IS ENTERED AT INLIN.
;
IFE	REALIO-4,<
INLIN:	LDXI	128		;NO PROMPT CHARACTER
	STX	CQPRMP
	JSR	CQINLN		;GET A LINE ONTO PAGE 2
	CPXI	BUFLEN-1
	BCS	GDBUFS		;NOT TOO MANY CHARACTERS
	LDXI	BUFLEN-1
GDBUFS: LDAI	0		;PUT A ZERO AT THE END
	STA	BUF,X
	TXA
	BEQ	NOCHR
LOPBHT: LDA	BUF-1,X
	ANDI	127
	STA	BUF-1,X
	DEX
	BNE	LOPBHT
NOCHR:	LDAI	0
	LDXYI	<BUF-1>		;POINT AT THE BEGINNING
	RTS>
IFN	REALIO-4,<
IFN	REALIO-3,<
LINLIN: IFE	REALIO-2,<
	JSR	OUTDO>		;ECHO IT.
	DEX			;BACKARROW SO BACKUP PNTR AND
	BPL	INLINC		;GET ANOTHER IF COUNT IS POSITIVE.
INLINN: IFE	REALIO-2,<
	JSR	OUTDO>		;PRINT THE @ OR A SECOND BACKARROW
				;IF THERE WERE TOO MANY.
	JSR	CRDO>
INLIN:	LDXI	0
INLINC: JSR	INCHR		;GET A CHARACTER.
IFN REALIO-3,<
	CMPI	7		;IS IT BOB ALBRECHT RINGING THE BELL
				;FOR SCHOOL KIDS?
	BEQ	GOODCH>
	CMPI	13		;CARRIAGE RETURN?
	BEQ	FININ1		;YES, FINISH UP.
IFN	REALIO-3,<
	CMPI	32		;CHECK FOR FUNNY CHARACTERS.
	BCC	INLINC
	CMPI	125		;IS IT TILDA OR DELETE?
	BCS	INLINC		;BIG BAD ONES TOO.
	CMPI	"@"		;LINE DELETE?
	BEQ	INLINN		;YES.
	CMPI	"_"		;CHARACTER DELETE?
	BEQ	LINLIN>		;YES.
GOODCH:
IFN	REALIO-3,<
	CPXI	BUFLEN-1	;LEAVE ROOM FOR NULL.
			;COMMO ASSURES US NEVER MORE THAN BUFLEN.
	BCS	OUTBEL>
	STA	BUF,X
	INX
IFE	REALIO-2,<SKIP2>
IFN	REALIO-2,<BNE INLINC>
IFN REALIO-3,<
OUTBEL: LDAI	7
IFN	REALIO,<
	JSR	OUTDO>		;ECHO IT.
	BNE	INLINC>		;CYCLE ALWAYS.
FININ1: JMP	FININL>		;GO TO FININL FAR, FAR AWAY.
INCHR:	
IFE	REALIO-3,<
	JSR	CQINCH>		;FOR COMMODORE.
IFE	REALIO-2,<
INCHRL: LDA	^O176000
	REPEAT	4,<NOP>
	LSR	A,
	BCC	INCHRL
	LDA	^O176001	;GET THE CHARACTER.
	REPEAT	4,<NOP>
	ANDI	127>
IFE	REALIO-1,<
	JSR	^O17132>	;1E5A FOR MOS TECH.
IFE	REALIO-4,<
	JSR	CQINCH		;FD0C FOR APPLE COMPUTER.
	ANDI	127>
IFE	REALIO,<
	TJSR	INSIM##>	;GET A CHARACTER FROM SIMULATOR

IFN	REALIO,<
IFN	EXTIO,<
	LDY	CHANNL		;CNT-O HAS NO EFFECT IF NOT FROM TERM.
	BNE	INCRTS>
	CMPI	CONTW		;SUPPRESS OUTPUT CHARACTER (^W).
	BNE	INCRTS		;NO, RETURN.
	PHA
	COM	CNTWFL		;COMPLEMENT ITS STATE.
	PLA>
INCRTS: RTS			;END OF INCHR.
	
;
; ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE
; BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME 
; BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION.
; THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE
; RESERVED WORD LIST IN THE SAME ORDER THEY
; APPEAR IN STMDSP.
;
BUFOFS=0			;THE AMOUNT TO OFFSET THE LOW BYTE
				;OF THE TEXT POINTER TO GET TO BUF
				;AFTER TXTPTR HAS BEEN SETUP TO POINT INTO BUF
IFN	BUFPAG,<
BUFOFS=<BUF/256>*256>
CRUNCH: LDX	TXTPTR		;SET SOURCE POINTER.
	LDYI	4		;SET DESTINATION OFFSET.
	STY	DORES		;ALLOW CRUNCHING.
KLOOP:	LDA	BUFOFS,X
IFE	REALIO-3,<
	BPL	CMPSPC		;GO LOOK AT SPACES.
	CMPI	PI		;PI??
	BEQ	STUFFH		;GO SAVE IT.
	INX			;SKIP NO PRINTING.
	BNE	KLOOP>		;ALWAYS GOES.
CMPSPC: CMPI	" "		;IS IT A SPACE TO SAVE?
	BEQ	STUFFH		;YES, GO SAVE IT.
	STA	ENDCHR		;IF IT'S A QUOTE, THIS WILL
				;STOP LOOP WHEN OTHER QUOTE APPEARS.
	CMPI	34		;QUOTE SIGN?
	BEQ	STRNG		;YES, DO SPECIAL STRING HANDLING.
	BIT	DORES		;TEST FLAG.
	BVS	STUFFH		;NO CRUNCH, JUST STORE.
	CMPI	"?"		;A QMARK?
	BNE	KLOOP1
	LDAI	PRINTK		;YES, STUFF A "PRINT" TOKEN.
	BNE	STUFFH		;ALWAYS GO TO STUFFH.
KLOOP1: CMPI	"0"		;SKIP NUMERICS.
	BCC	MUSTCR
	CMPI	60		;":" AND ";" ARE ENTERED STRAIGHTAWAY.
	BCC	STUFFH
MUSTCR: STY	BUFPTR		;SAVE BUFFER POINTER.
	LDYI	0		;LOAD RESLST POINTER.
	STY	COUNT		;ALSO CLEAR COUNT.
	DEY
	STX	TXTPTR		;SAVE TEXT POINTER FOR LATER USE.
	DEX
RESER:	INY
RESPUL: INX
RESCON: LDA	BUFOFS,X
	SEC			;PREPARE TO SUBSTARCT.
	SBC	RESLST,Y	;CHARACTERS EQUAL?
	BEQ	RESER		;YES, CONTINUE SEARCH.
	CMPI	128		;NO BUT MAYBE THE END IS HERE.
	BNE	NTHIS		;NO, TRULY UNEQUAL.
	ORA	COUNT
GETBPT: LDY	BUFPTR		;GET BUFFER PNTR.
STUFFH: INX
	INY
	STA	BUF-5,Y
	LDA	BUF-5,Y
	BEQ	CRDONE		;NULL IMPLIES END OF LINE.
	SEC			;PREPARE TO SUBSTARCT.
	SBCI	":"		;IS IT A ":"?
	BEQ	COLIS		;YES, ALLOW CRUNCHING AGAIN.
	CMPI	DATATK-":"	;IS IT A DATATK?
	BNE	NODATT		;NO, SEE IF IT IS REM TOKEN.
COLIS:	STA	DORES		;SETUP FLAG.
NODATT: SEC			;PREP TO SBCQ
	SBCI	REMTK-":"	;REM ONLY STOPS ON NULL.
	BNE	KLOOP		;NO, CONTINUE CRUNCHING.
	STA	ENDCHR		;REM STOPS ONLY ON NULL, NOT : OR ".
STR1:	LDA	BUFOFS,X
	BEQ	STUFFH		;YES, END OF LINE, SO DONE.
	CMP	ENDCHR		;END OF GOBBLE?
	BEQ	STUFFH		;YES, DONE WITH STRING.
STRNG:	INY			;INCREMENT BUFFER POINTER.
	STA	BUF-5,Y
	INX
	BNE	STR1		;PROCESS NEXT CHARACTER.
NTHIS:	LDX	TXTPTR		;RESTORE TEXT POINTER.
	INC	COUNT		;INCREMENT RES WORD COUNT.
NTHIS1: INY
	LDA	RESLST-1,Y,	;GET RES CHARACTER.
	BPL	NTHIS1		;END OF ENTRY?
	LDA	RESLST,Y,	;YES. IS IT THE END?
	BNE	RESCON		;NO, TRY THE NEXT WORD.
	LDA	BUFOFS,X	;YES, END OF TABLE. GET 1ST CHR.
	BPL	GETBPT		;STORE IT AWAY (ALWAYS BRANCHES).
CRDONE: STA	BUF-3,Y,	;SO THAT IF THIS IS A DIR STATEMENT
				;ITS END WILL LOOK LIKE END OF PROGRAM.
IFN	<<BUF+BUFLEN>/256>-<<BUF-1>/256>,<
	DEC	TXTPTR+1>
	LDAI	<BUF&255>-1	;MAKE TXTPTR POINT TO
	STA	TXTPTR		;CRUNCHED LINE.
LISTRT: RTS			;RETURN TO CALLER.
;
; FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE
; WHOSE NUMBER IS PASSED IN "LINNUM".
; THERE ARE TWO POSSIBLE RETURNS:
;
;	1) CARRY SET.
;	   LOWTR POINTS TO THE LINK FIELD IN THE LINE
;	   WHICH IS THE ONE SEARCHED FOR.
;
;	2) CARRY NOT SET.
;	   LINE NOT FOUND. [LOWTR] POINTS TO THE LINE IN THE
;	   PROGRAM GREATER THAN THE ONE SOUGHT AFTER.
;
FNDLIN: LDWX	TXTTAB		;LOAD [X,A] WITH [TXTTAB]
FNDLNC: LDYI	1
	STWX	LOWTR		;STORE [X,A] INTO LOWTR
	LDADY	LOWTR		;SEE IF LINK IS 0
	BEQ	FLINRT
	INY
	INY
	LDA	LINNUM+1	;COMP HIGH ORDERS OF LINE NUMBERS.
	CMPDY	LOWTR
	BCC	FLNRTS		;NO SUCH LINE NUMBER.
	BEQ	FNDLO1
	DEY
	BNE	AFFRTS		;ALWAYS BRANCH.
FNDLO1: LDA	LINNUM
	DEY
	CMPDY	LOWTR		;COMPARE LOW ORDERS.
	BCC	FLNRTS		;NO SUCH NUMBER.
	BEQ	FLNRTS		;GO TIT.
AFFRTS: DEY
	LDADY	LOWTR		;FETCH LINK.
	TAX
	DEY
	LDADY	LOWTR
	BCS	FNDLNC		;ALWAYS BRANCHES.
FLINRT: CLC			;C MAY BE HIGH.
FLNRTS: RTS			;RETURN TO CALLER.
;
; THE "NEW" COMMAND CLEARS THE PROGRAM TEXT AS WELL
; AS VARIABLE SPACE.
;
SCRATH: BNE	FLNRTS		;MAKE SURE THERE IS A TERMINATOR.
SCRTCH: LDAI	0		;GET A CLEARER.
	TAY			;SET UP INDEX.
	STADY	TXTTAB		;CLEAR	FIRST LINK.
	INY
	STADY	TXTTAB
	LDA	TXTTAB
	CLC
	ADCI	2
	STA	VARTAB		;SETUP [VARTAB].
	LDA	TXTTAB+1
	ADCI	0
	STA	VARTAB+1
RUNC:	JSR	STXTPT
	LDAI	0		;SET ZERO FLAG
;
; THIS CODE IS FOR THE CLEAR COMMAND.
;
CLEAR:	BNE	STKRTS		;SYNTAX ERROR IF NO TERMINATOR.
;
; CLEAR INITIALIZES THE VARIABLE AND
; ARRAY SPACE BY RESETING ARYTAB (THE END OF SIMPLE VARIABLE SPACE)
; AND STREND (THE END OF ARRAY STORAGE). IT FALLS INTO "STKINI"
; WHICH RESETS THE STACK. 
;
CLEARC: LDWD	MEMSIZ		;FREE UP STRING SPACE.
	STWD	FRETOP
IFN	EXTIO,<
	JSR	CQCALL>		;CLOSE ALL OPEN FILES.
	LDWD	VARTAB		;LIBERATE THE
	STWD	ARYTAB		;VARIABLES AND
	STWD	STREND		;ARRAYS.
FLOAD:	JSR	RESTOR		;RESTORE DATA.
;
; STKINI RESETS THE STACK POINTER ELIMINATING
; GOSUB AND FOR CONTEXT. STRING TEMPORARIES ARE FREED
; UP, SUBFLG IS RESET. CONTINUING IS PROHIBITED.
; AND A DUMMY ENTRY IS LEFT AT THE BOTTOM OF THE STACK SO "FNDFOR" WILL ALWAYS
; FIND A NON-"FOR" ENTRY AT THE BOTTOM OF THE STACK.
;
STKINI: LDXI	TEMPST		;INITIALIZE STRING TEMPORARIES.
	STX	TEMPPT
	PLA			;SETUP RETURN ADDRESS.
	TAY
	PLA
	LDXI	STKEND-257
	TXS
	PHA
	TYA
	PHA
	LDAI	0
	STA	OLDTXT+1	;DISALLOWING CONTINUING
	STA	SUBFLG		;ALLOW SUBSCRIPTS.
STKRTS: RTS

STXTPT: CLC
	LDA	TXTTAB
	ADCI	255
	STA	TXTPTR
	LDA	TXTTAB+1
	ADCI	255
	STA	TXTPTR+1	;SETUP TEXT POINTER.
	RTS
PAGE
