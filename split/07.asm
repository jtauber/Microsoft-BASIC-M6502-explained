SUBTTL	GENERAL STORAGE MANAGEMENT ROUTINES.
;
; FIND A "FOR" ENTRY ON THE STACK VIA "VARPNT".
;
FORSIZ==2*ADDPRC+16
FNDFOR: TSX			;LOAD XREG WITH STK PNTR.
	REPEAT	4,<INX>		;IGNORE ADR(NEWSTT) AND RTS ADDR.
FFLOOP: LDA	257,X		;GET STACK ENTRY.
	CMPI	FORTK		;IS IT A "FOR" TOKEN?
	BNE	FFRTS		;NO, NO "FOR" LOOPS WITH THIS PNTR.
	LDA	FORPNT+1	;GET HIGH.
	BNE	CMPFOR
	LDA	258,X		;PNTR IS ZERO, SO ASSUME THIS ONE.
	STA	FORPNT
	LDA	259,X
	STA	FORPNT+1
CMPFOR: CMP	259,X
	BNE	ADDFRS		;NOT THIS ONE.
	LDA	FORPNT		;GET DOWN.
	CMP	258,X
	BEQ	FFRTS		;WE GOT IT! WE GOT IT!
ADDFRS: TXA
	CLC			;ADD 16 TO X.
	ADCI	FORSIZ
	TAX			;RESULT BACK INTO X.
	BNE	FFLOOP
FFRTS:	RTS			;RETURN TO CALLER.

;
; THIS IS THE BLOCK TRANSFER ROUTINE.
; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD.
;
; ON ENTRY:
; [Y,A]=[HIGHDS]    (FOR REASON).
; [HIGHDS]= DESTINATION OF [HIGH ADDRESS].
; [LOWTR]= LOWEST ADDR TO BE TRANSFERRED.
; [HIGHTR]= HIGHEST ADDR TO BE TRANSFERRED.
;
; A CHECK IS MADE TO ASCERTAIN THAT A REASONABLE
; AMOUNT OF SPACE REMAINS BETWEEN THE BOTTOM
; OF THE STRINGS AND THE HIGHEST LOCATION TRANSFERRED INTO.
;
; ON EXIT:
; [LOWTR] ARE UNCHANGED.
; [HIGHTR]=[LOWTR]-200 OCTAL.
; [HIGHDS]=LOWEST ADDR TRANSFERRED INTO MINUS 200 OCTAL.
;
BLTU:	JSR	REASON		;ASCERTAIN THAT STRING SPACE WON'T
				;BE OVERRUN.
	STWD	STREND
BLTUC:	SEC			;PREPARE TO SUBTRACT.
	LDA	HIGHTR
	SBC	LOWTR		;COMPUTE NUMBER OF THINGS TO MOVE.
	STA	INDEX		;SAVE FOR LATER.
	TAY
	LDA	HIGHTR+1
	SBC	LOWTR+1
	TAX			;PUT IT IN A COUNTER REGISTER.
	INX			;SO THAT COUNTER ALGORITHM WORKS.
	TYA			;SEE IF LOW PART OF COUNT IS ZERO.
	BEQ	DECBLT		;YES, GO START MOVING BLOCKS.
	LDA	HIGHTR		;NO, MUST MODIFY BASE ADDR.
	SEC
	SBC	INDEX		;BORROW IS OFF SINCE [HIGHTR].GT.[LOWTR].
	STA	HIGHTR		;SAVE MODIFIED BASE ADDR.
	BCS	BLT1		;IF NO BORROW, GO SHOVE IT.
	DEC	HIGHTR+1	;BORROW IMPLIES SUB 1 FROM HIGH ORDER.
	SEC
BLT1:	LDA	HIGHDS		;MOD BASE OF DEST ADDR.
	SBC	INDEX
	STA	HIGHDS
	BCS	MOREN1		;NO BORROW.
	DEC	HIGHDS+1	;DECREMENT HIGH ORDER BYTE.
	BCC	MOREN1		;ALWAYS SKIP.
BLTLP:	LDADY	HIGHTR		;FETCH BYTE TO MOVE
	STADY	HIGHDS		;MOVE IT IN, MOVE IT OUT.
MOREN1: DEY
	BNE	BLTLP
	LDADY	HIGHTR		;MOVE LAST OF THE BLOCK.
	STADY	HIGHDS
DECBLT: DEC	HIGHTR+1
	DEC	HIGHDS+1	;START ON NEW BLOCKS.
	DEX
	BNE	MOREN1
	RTS			;RETURN TO CALLER.

;
; THIS ROUTINE IS USED TO ASCERTAIN THAT A GIVEN
; NUMBER OF LOCS REMAIN AVAILABLE FOR THE STACK.
;    THE CALL IS:
;	LDAI	NUMBER OF 2-BYTE ENTRIES NEEDED.
;	JSR	GETSTK
;
; THIS ROUTINE MUST BE CALLED BY ANY ROUTINE WHICH PUTS
; AN ARBITRARY AMOUNT OF STUFF ON THE STACK,
; I.E., ANY RECURSIVE ROUTINE LIKE "FRMEVL".
; IT IS ALSO CALLED BY ROUTINES SUCH AS "GOSUB" AND "FOR"
; WHICH MAKE PERMANENT ENTRIES ON THE STACK.
;
; ROUTINES WHICH MERELY USE AND FREE UP THE GUARANTEED
; NUMLEV LOCATIONS NEED NOT CALL THIS.
;
;
; ON EXIT:
;    [A] AND [X] HAVE BEEN MODIFIED.
;
GETSTK: ASL	A,		;MULT [A] BY 2. NB, CLEARS C BIT.
	ADCI	2*NUMLEV+<3*ADDPRC>+13	;MAKE SURE 2*NUMLEV+13 LOCS
				;(13 BECAUSE OF FBUFFR)
	BCS	OMERR		;WILL REMAIN IN STACK.
	STA	INDEX
	TSX			;GET STACKED.
	CPX	INDEX		;COMPARE.
	BCC	OMERR		;IF STACK.LE.INDEX1, OM.
	RTS

;
; [Y,A] IS A CERTAIN ADDRESS. "REASON" MAKES SURE
; IT IS LESS THAN [FRETOP].
;
REASON: CPY	FRETOP+1
	BCC	REARTS
	BNE	TRYMOR		;GO GARB COLLECT.
	CMP	FRETOP
	BCC	REARTS
TRYMOR: PHA
	LDXI	8+ADDPRC	;IF TEMPF2 HAS ZERO IN BETWEEN.
	TYA
REASAV: PHA
	LDA	HIGHDS-1,X	;SAVE HIGHDS ON STACK.
	DEX
	BPL	REASAV		;PUT 8 OF THEM ON STK.
	JSR	GARBA2		;GO GARB COLLECT.
	LDXI	256-8-ADDPRC
REASTO: PLA
	STA	HIGHDS+8+ADDPRC,X	;RESTORE AFTER GARB COLLECT.
	INX
	BMI	REASTO
	PLA
	TAY
	PLA			;RESTORE A AND Y.
	CPY	FRETOP+1	;COMPARE HIGHS
	BCC	REARTS
	BNE	OMERR		;HIGHER IS BAD.
	CMP	FRETOP		;AND THE LOWS.
	BCS	OMERR
REARTS: RTS

PAGE
