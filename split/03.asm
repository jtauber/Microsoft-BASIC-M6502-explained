SUBTTL	SOME EXPLANATION.
COMMENT *

M6502 BASIC CONFIGURES BASIC AS FOLLOWS

LOW LOCATIONS
	PAGE	ZERO

		STARTUP:
		INITIALLY A JMP TO INITIALIZATION CODE BUT
		CHANGED TO A JMP TO "READY".
		RESTARTING THE MACHINE AT LOC 0 DURING PROGRAM
		EXECUTION CAN LEAVE THINGS MESSED UP.

		LOC OF FAC TO INTEGER AND INTEGER TO FAC 
		ROUTINES.

		"DIRECT" MEMORY:
		THESE ARE THE MOST COMMONLY USED LOCATIONS.
		THEY HOLD BOOKKEEPING INFO AND ALL OTHER
		FREQUENTLY USED INFORMATION.
		ALL TEMPORARIES, FLAGS, POINTERS, THE BUFFER AREA,
		THE FLOATING ACCUMULATOR, AND ANYTHING ELSE THAT
		IS USED TO STORE A CHANGING VALUE SHOULD BE LOCATED
		IN THIS AREA. CARE MUST BE MADE IN MOVING LOCATIONS
		IN THIS AREA SINCE THE JUXTAPOSITION OF TWO LOCATIONS
		IS OFTEN DEPENDED UPON.

		STILL IN RAM WE HAVE THE BEGINNING OF THE "CHRGET"
		SUBROUTINE. IT IS HERE SO [TXTPTR] CAN BE THE
		EXTENDED ADDRESS OF A LOAD INSTRUCTION.
		THIS SAVES HAVING TO BOTHER ANY REGISTERS.

	PAGE	ONE
		THE STACK.

	STORAGE PAGE TWO AND ON
		IN RAM VERSIONS THESE DATA STRUCTURES COME AT THE
		END OF BASIC. IN ROM VERSON THEY ARE AT RAMLOC WHICH
		CAN EITHER BE ABOVE OR BELOW ROMLOC, WHICH IS WHERE
		BASIC ITSELF RESIDES.

				A ZERO.
		[TXTTAB]	POINTER TO NEXT LINE'S POINTER.
				LINE # OF THIS LINE (2 BYTES).
				CHARACTERS ON THIS LINE.
				ZERO.
				POINTER AT NEXT LINE'S POINTER
					(POINTED TO BY THE ABOVE POINTER).
				... REPEATS ...
		LAST LINE:	POINTER AT ZERO POINTER.
				LINE # OF THIS LINE.
				CHARACTERS ON THIS LINE.
				ZERO.
				DOUBLE ZERO (POINTED TO BY THE ABOVE POINTER).
		[VARTAB]	SIMPLE VARIABLES. 6 BYTES PER VALUE.
				2 BYTES GIVE THE NAME, 4 BYTES THE VALUE.
				... REPEATS ...
		[ARYTAB]	ARRAY VARIABLES. 2 BYTES NAME, 2 BYTE
				LENGTH, NUMBER OF DIMENSIONS , EXTENT OF
				EACH DIMENSION (2BYTES/), VALUES
				... REPEATS ...
		[STREND]	FREE SPACE.
				... REPEATS ...
		[FRETOP]	STRING SPACE IN USE.
				... REPEATS ...
		[MEMSIZ]	HIGHEST MACHINE LOCATION.
				UNUSED EXCEPT BY THE VAL FUNCTION.

		ROM -- CONSTANTS AND CODE.

	FUNCTION DISPATCH ADDRESSES (AT ROMLOC)
		"FUNDSP" CONTAINS THE ADDRESSES OF THE
		FUNCTION ROUTINES IN THE ORDER OF THE
		FUNCTION NAMES IN THE CRUNCH LIST.
		THE FUNCTIONS THAT TAKE MORE THAN ONE ARGUMENT
		ARE AT THE END. SEE THE EXPLANATION AT "ISFUN".

	THE OPERATOR LIST
		THE "OPTAB" LIST CONTAINS AN OPERATOR'S PRECEDENCE
		FOLLOWED BY THE ADDRESS OF THE ROUTINE TO PERFORM
		THE OPERATION. THE INDEX INTO THE
		OPERATOR LIST IS MADE BY SUBTRACTING OFF THE CRUNCH VALUE
		OF THE LOWEST NUMBERED OPERATOR. THE ORDER
		OF OPERATORS IN THE CRUNCH LIST AND IN "OPTAB" IS IDENTICAL.
		THE PRECEDENCES ARE ARBITRARY EXCEPT FOR THEIR
		COMPARATIVE SIZES. NOTE THAT THE PRECEDENCE FOR
		UNARY OPERATORS SUCH AS "NOT" AND NEGATION ARE
		SETUP SPECIALLY WITHOUT USING THE LIST.

	THE RESERVED WORD OR CRUNCH LIST
		WHEN A COMMAND OR PROGRAM LINE IS TYPED IN
		IT IS STORED IN "BUF". AS SOON AS THE WHOLE LINE
		HAS BEEN TYPED IN ("INLIN" RETURNS) "CRUNCH" IS
		CALLED TO CONVERT ALL RESERVED WORDS TO THEIR
		CRUNCHED VALUES. THIS REDUCES THE SIZE OF THE 
		PROGRAM AND SPEEDS UP EXECUTION BY ALLOWING
		LIST DISPATCHES TO PERFORM FUNCTIONS, STATEMENTS,
		AND OPERATIONS. THIS IS BECAUSE ALL THE STATEMENT
		NAMES ARE STORED CONSECUTIVELY IN THE CRUNCH LIST.
		WHEN A MATCH IS FOUND BETWEEN A STRING
		OF CHARACTERS AND A WORD IN THE CRUNCH LIST
		THE ENTIRE TEXT OF THE MATCHED WORD IS TAKEN OUT OF
		THE INPUT LINE AND A RESERVED WORD TOKEN IS PUT
		IN ITS PLACE. A RESERVED WORD TOKEN IS ALWAYS EQUAL
		TO OCTAL 200 PLUS THE POSITION OF THE MATCHED WORD
		IN THE CRUNCH LIST.

	STATEMENT DISPATCH ADDRESSES
		WHEN A STATEMENT IS TO BE EXECUTED, THE FIRST
		CHARACTER OF THE STATEMENT IS EXAMINED
		TO SEE IF IT IS LESS THAN THE RESERVED
		WORD TOKEN FOR THE LOWEST NUMBERED STATEMENT NAME.
		IF SO, THE "LET" CODE IS CALLED TO
		TREAT THE STATEMENT AS AN ASSIGNMENT STATEMENT.
		OTHERWISE A CHECK IS MADE TO MAKE SURE THE
		RESERVED WORD NUMBER IS NOT TOO LARGE TO BE A
		STATEMENT TYPE NUMBER. IF NOT THE ADDRESS
		TO DISPATCH TO IS FETCHED FROM "STMDSP" (THE STATEMENT
		DISPATCH LIST) USING THE RESERVED WORD
		NUMBER FOR THE STATEMENT TO CALCULATE AN INDEX INTO
		THE LIST.

	ERROR MESSAGES
		WHEN AN ERROR CONDITION IS DETECTED,
		[ACCX] MUST BE SET UP TO INDICATE WHICH ERROR
		MESSAGE IS APPROPRIATE AND A BRANCH MUST BE MADE
		TO "ERROR". THE STACK WILL BE RESET AND ALL
		PROGRAM CONTEXT WILL BE LOST. VARIABLES
		VALUES AND THE ACTUAL PROGRAM REMAIN INTACT.
		ONLY THE VALUE OF [ACCX] IS IMPORTANT WHEN
		THE BRANCH IS MADE TO ERROR. [ACCX] IS USED AS AN
		INDEX INTO "ERRTAB" WHICH GIVES THE TWO
		CHARACTER ERROR MESSAGE THAT WILL BE PRINTED ON THE
		USER'S TERMINAL.


	TEXTUAL MESSAGES
		CONSTANT MESSAGES ARE STORED HERE. UNLESS
		THE CODE TO CHECK IF A STRING MUST BE COPIED
		IS CHANGED THESE STRINGS MUST BE STORED ABOVE
		PAGE ZERO, OR ELSE THEY WILL BE COPIED BEFORE
		THEY ARE PRINTED.

	FNDFOR	
		MOST SMALL ROUTINES ARE FAIRLY SIMPLE
		AND ARE DOCUMENTED IN PLACE. "FNDFOR" IS
		USED FOR FINDING "FOR" ENTRIES ON
		THE STACK. WHENEVER A "FOR" IS EXECUTED, A
		16-BYTE ENTRY IS PUSHED ONTO THE STACK.
		BEFORE THIS IS DONE, HOWEVER, A CHECK
		MUST BE MADE TO SEE IF THERE
		ARE ANY "FOR" ENTRIES ALREADY ON THE STACK
		FOR THE SAME LOOP VARIABLE. IF SO, THAT "FOR" ENTRY
		AND ALL OTHER "FOR" ENTRIES THAT WERE MADE AFTER IT
		ARE ELIMINATED FROM THE STACK. THIS IS SO A
		PROGRAM THAT JUMPS OUT OF THE MIDDLE
		OF A "FOR" LOOP AND THEN RESTARTS THE LOOP AGAIN
		AND AGAIN WON'T USE UP 18 BYTES OF STACK
		SPACE EVERY TIME. THE "NEXT" CODE ALSO
		CALLS "FNDFOR" TO SEARCH FOR A "FOR" ENTRY WITH
		THE LOOP VARIABLE IN
		THE "NEXT". AT WHATEVER POINT A MATCH IS FOUND
		THE STACK IS RESET. IF NO MATCH IS FOUND A
		"NEXT WITHOUT FOR"  ERROR OCCURS. GOSUB EXECUTION
		ALSO PUTS A 5-BYTE ENTRY ON STACK.
		WHEN A RETURN IS EXECUTED "FNDFOR" IS
		CALLED WITH A VARIABLE POINTER THAT CAN'T
		BE MATCHED. WHEN "FNDFOR" HAS RUN
		THROUGH ALL THE "FOR" ENTRIES ON THE STACK  
		IT RETURNS AND THE RETURN CODE MAKES
		SURE THE ENTRY THAT WAS STOPPED
		ON IS A GOSUB ENTRY. THIS ASSURES THAT
		IF YOU GOSUB TO A SECTION OF CODE
		IN WHICH A FOR LOOP IS ENTERED BUT NEVER
		EXITED THE RETURN WILL STILL BE
		ABLE TO FIND THE MOST RECENT
		GOSUB ENTRY. THE "RETURN" CODE ELIMINATES THE
		"GOSUB" ENTRY AND ALL "FOR" ENTRIES MADE AFTER
		THE GOSUB ENTRY.

	NON-RUNTIME STUFF
		THE CODE TO INPUT A LINE, CRUNCH IT, GIVE ERRORS,
		FIND A SPECIFIC LINE IN THE PROGRAM,
		PERFORM A "NEW", "CLEAR", AND "LIST" ARE
		ALL IN THIS AREA. GIVEN THE EXPLANATION OF
		PROGRAM STORAGE SET FORTH ABOVE, THESE ARE
		ALL STRAIGHTFORWARD.

	NEWSTT
		WHENEVER A STATEMENT FINISHES EXECUTION IT
		DOES A "RTS" WHICH TAKES
		EXECUTION BACK TO "NEWSTT". STATEMENTS THAT
		CREATE OR LOOK AT SEMI-PERMANENT STACK ENTRIES
		MUST GET RID OF THE RETURN ADDRESS OF "NEWSTT" AND
		JMP TO "NEWSTT" WHEN DONE. "NEWSTT" ALWAYS
		CHRGETS THE FIRST CHARACTER AFTER THE STATEMENT
		NAME BEFORE DISPATCHING. WHEN RETURNING
		BACK TO "NEWSTT" THE ONLY THING THAT
		MUST BE SET UP IS THE TEXT POINTER IN
		"TXTPTR". "NEWSTT" WILL CHECK TO MAKE SURE
		"TXTPTR" IS POINTING TO A STATEMENT TERMINATOR.
		IF A STATEMENT SHOULDN'T BE PERFORMED UNLESS
		IT IS PROPERLY FORMATTED (I.E. "NEW") IT CAN
		SIMPLY DO A RETURN AFTER READING ALL OF
		ITS ARGUMENTS. SINCE THE ZERO FLAG
		BEING OFF INDICATES THERE IS NOT
		A STATEMENT TERMINATOR "NEWSTT" WILL
		DO THE JMP TO THE "SYNTAX ERROR"
		ROUTINE. IF A STATEMENT SHOULD BE STARTED
		OVER IT CAN DO LDWD OLDTXT, STWD TXTPTR RTS SINCE THE TEXT PNTR
		AT "NEWSTT" IS ALWAYS STORED IN "OLDTXT".
		THE ^C CODE STORES [CURLIN] (THE
		CURRENT LINE NUMBER) IN "OLDLIN" SINCE THE ^C CHECK
		IS MADE BEFORE THE STATEMENT POINTED TO IS
		EXECUTED. "STOP" AND "END" STORE THE TEXT POINTER
		FROM "TXTPTR", WHICH POINTS AT THEIR TERMINATING
		CHARACTER, IN "OLDTXT".

	STATEMENT CODE
		THE INDIVIDUAL STATEMENT CODE COMES
		NEXT. THE APPROACH USED IN EXECUTING EACH
		STATEMENT IS DOCUMENTED IN THE STATEMENT CODE
		ITSELF.

	FRMEVL, THE FORMULA EVALUATOR
		GIVEN A TEXT POINTER POINTING TO THE STARTING
		CHARACTER OF A FORMULA, "FRMEVL"
		EVALUATES THE FORMULA AND LEAVES
		THE VALUE IN THE FLOATING ACCUMULATOR (FAC).
		"TXTPTR" IS RETURNED POINTING TO THE FIRST CHARACTER
		THAT COULD NOT BE INTERPRETED AS PART OF THE
		FORMULA. THE ALGORITHM USES THE STACK
		TO STORE TEMPORARY RESULTS:

			0. PUT A DUMMY PRECEDENCE OF ZERO ON
				THE STACK.
			1. READ LEXEME (CONSTANT,FUNCTION,
				VARIABLE,FORMULA IN PARENS)
				AND TAKE THE LAST PRECEDENCE VALUE
				OFF THE STACK.
			2. SEE IF THE NEXT CHARACTER IS AN OPERATOR.
				IF NOT, CHECK PREVIOUS ONE. THIS MAY CAUSE
				OPERATOR APPLICATION OR AN ACTUAL
				RETURN FROM "FRMEVL".
			3. IF IT IS, SEE WHAT PRECEDENCE IT HAS
				AND COMPARE IT TO THE PRECEDENCE
				OF THE LAST OPERATOR ON THE STACK.
			4. IF = OR LESS REMEMBER THE OPERATOR
				POINTER OF THIS OPERATOR
				AND BRANCH TO "QCHNUM" TO CAUSE
				APPLICATION OF THE LAST OPERATOR.
				EVENTUALLY RETURN TO STEP 2
				BY RETURNING TO JUST AFTER "DOPREC".
			5. IF GREATER PUT THE LAST PRECEDENCE
				BACK ON, SAVE THE OPERATOR ADDRESS,
				CURRENT TEMPORARY RESULT,
				AND PRECEDENCE AND RETURN TO STEP 1.

		RELATIONAL OPERATORS ARE ALL HANDLED THROUGH
		A COMMON ROUTINE. SPECIAL
		CARE IS TAKEN TO DETECT TYPE MISMATCHES SUCH AS 3+"F".

	EVAL -- THE ROUTINE TO READ A LEXEME
		"EVAL" CHECKS FOR THE DIFFERENT TYPES OF
		ENTITIES IT IS SUPPOSED TO DETECT.
		LEADING PLUSES ARE IGNORED,
		DIGITS AND "." CAUSE "FIN" (FLOATING INPUT)
		TO BE CALLED. FUNCTION NAMES CAUSE THE
		FORMULA INSIDE THE PARENTHESES TO BE EVALUATED
		AND THE FUNCTION ROUTINE TO BE CALLED. VARIABLE
		NAMES CAUSE "PTRGET" TO BE CALLED TO GET A POINTER
		TO THE VALUE, AND THEN THE VALUE IS PUT INTO
		THE FAC. AN OPEN PARENTHESIS CAUSES "FRMEVL"
		TO BE CALLED (RECURSIVELY), AND THE ")" TO
		BE CHECKED FOR. UNARY OPERATORS (NOT AND
		NEGATION)  PUT THEIR PRECEDENCE ON THE STACK
		AND ENTER FORMULA EVALUATION AT STEP 1, SO
		THAT EVERYTHING UP TO AN OPERATOR GREATER THAN
		THEIR PRECEDENCE OR THE END OF THE FORMULA
		WILL BE EVALUATED.

	DIMENSION AND VARIABLE SEARCHING
		SPACE IS ALLOCATED FOR VARIABLES AS THEY ARE
		ENCOUNTERED. THUS "DIM" STATEMENTS MUST BE
		EXECUTED TO HAVE EFFECT. 6 BYTES ARE ALLOCATED
		FOR EACH SIMPLE VARIABLE, WHETHER IT IS A STRING,
		NUMBER OR USER DEFINED FUNCTION. THE FIRST TWO
		BYTES GIVE THE NAME OF THE VARIABLE AND THE LAST FOUR
		GIVE ITS VALUE. [VARTAB] GIVES THE FIRST LOCATION
		WHERE A SIMPLE VARIABLE NAME IS FOUND AND [ARYTAB]
		GIVES THE LOCATION TO STOP SEARCHING FOR SIMPLE
		VARIABLES. A "FOR" ENTRY HAS A TEXT POINTER
		AND A POINTER TO A VARIABLE VALUE SO NEITHER
		THE PROGRAM OR THE SIMPLE VARIABLES CAN BE
		MOVED WHILE THERE ARE ACTIVE "FOR" ENTRIES ON THE STACK.
		USER DEFINED FUNCTION VALUES ALSO CONTAIN
		POINTERS INTO SIMPLE VARIABLE SPACE SO NO USER-DEFINED
		FUNCTION VALUES CAN BE RETAINED IF SIMPLE VARIABLES
		ARE MOVED. ADDING A SIMPLE VARIABLE IS JUST
		ADDING SIX TO [ARYTAB] AND [STREND], BLOCK TRANSFERING
		THE ARRAY VARIABLES UP BY SIX AND MAKING SURE THE
		NEW [STREND] IS NOT TOO CLOSE TO THE STRINGS.
		THIS MOVEMENT OF ARRAY VARIABLES MEANS
		THAT NO POINTER TO AN ARRAY WILL STAY VALID WHEN
		NEW SIMPLE VARIABLES CAN BE ENCOUNTERED. THIS IS
		WHY ARRAY VARIABLES ARE NOT ALLOWED FOR "FOR"
		LOOP VARIABLES. SETTING UP A NEW ARRAY VARIABLE
		MERELY INVOLVES BUILDING THE DESCRIPTOR,
		UPDATING [STREND], AND MAKING SURE THERE IS
		STILL ENOUGH ROOM BETWEEN [STREND] AND STRING SPACE.
		"PTRGET", THE ROUTINE WHICH RETURNS A POINTER
		TO A VARIABLE VALUE, HAS TWO IMPORTANT FLAGS. ONE IS
		"DIMFLG" WHICH INDICATES WHETHER "DIM" CALLED "PTRGET"
		OR NOT. IF SO, NO PRIOR ENTRY FOR THE VARIABLE IN
		QUESTION SHOULD BE FOUND, AND THE INDEX INDICATES
		HOW MUCH SPACE TO SET ASIDE. SIMPLE VARIABLES CAN
		BE "DIMENSIONED", BUT THE ONLY EFFECT WILL BE TO
		SET ASIDE SPACE FOR THE VARIABLE IF IT HASN'T BEEN
		ENCOUNTERED YET. THE OTHER IMPORTANT FLAG IS "SUBFLG"
		WHICH INDICATES WHETHER A SUBSCRIPTED VARIABLE SHOULD BE
		ALLOWED IN THE CURRENT CONTEXT. IF [SUBFLG] IS NON-ZERO
		THE OPEN PARENTHESIS FOR A SUBSCRIPTED VARIABLE
		WILL NOT BE SCANNED BY "PTRGET", AND "PTRGET" WILL RETURN
		WITH A TEXT POINTER POINTING TO THE "(", IF
		THERE WAS ONE.
	STRINGS
		IN THE VARIABLE TABLES STRINGS ARE STORED JUST LIKE
		NUMERIC VARIABLES. SIMPLE STRINGS HAVE THREE VALUE
		BYTES WHICH ARE INITIALIZED TO ALL ZEROS (WHICH
		REPRESENTS THE NULL STRING). THE ONLY DIFFERENCE
		IN HANDLING IS THAT WHEN "PTRGET" SEES A "$" AFTER THE
		NAME OF A VARIABLE, "PTRGET" SETS [VALTYP]
		TO NEGATIVE ONE AND TURNS
		ON THE MSB (MOST-SIGNIFIGANT-BIT) OF THE VALUE OF
		THE FIRST CHARACTER OF THE VARIABLE NAME.
		HAVING THIS BIT ON IN THE NAME OF THE VARIABLE ENSURES
		THAT THE SEARCH ROUTINE WILL NOT MATCH
		'A' WITH 'A$' OR 'A$' WITH 'A'. THE MEANING OF
		THE THREE VALUE BYTES ARE:
			LOW
				LENGTH OF THE STRING
				LOW 8 BITS
				HIGH 8 BITS  OF THE ADDRESS
					OF THE CHARACTERS IN THE
					STRING IF LENGTH.NE.0.
					MEANINGLESS OTHERWISE.
			HIGH
		THE VALUE OF A STRING VARIABLE (THESE 3 BYTES)
		IS CALLED THE STRING DESCRIPTOR TO DISTINGUISH
		IT FROM THE ACTUAL STRING DATA. WHENEVER A
		STRING CONSTANT IS ENCOUNTERED IN A FORMULA OR AS
		PART OF AN INPUT STRING, OR AS PART OF DATA, "STRLIT"
		IS CALLED, CAUSING A DESCRIPTOR TO BE BUILT FOR
		THE STRING. WHEN ASSIGNMENT IS MADE TO A STRING POINTING INTO
		"BUF" THE VALUE IS COPIED INTO STRING SPACE SINCE [BUF]
		IS ALWAYS CHANGING.

		STRING FUNCTIONS AND THE ONE STRING OPERATOR "+"
		ALWAYS RETURN THEIR VALUES IN STRING SPACE.
		ASSIGNING A STRING A CONSTANT VALUE IN A PROGRAM
		THROUGH A "READ" OR ASSIGNMENT STATEMENT
		WILL NOT USE ANY STRING SPACE SINCE
		THE STRING DESCRIPTOR  WILL POINT INTO THE
		PROGRAM ITSELF. IN GENERAL, COPYING IS DONE
		WHEN A STRING VALUE IS IN "BUF", OR IT IS IN STRING
		SPACE AND THERE IS AN ACTIVE POINTER TO IT.
		THUS F$=G$ WILL CAUSE COPYING IF G$ HAS ITS
		STRING DATA IN STRING SPACE. F$=CHR$(7)
		WILL USE ONE BYTE OF STRING SPACE TO STORE THE
		NEW ONE CHARACTER STRING CREATED BY "CHR$", BUT
		THE ASSIGNMENT ITSELF WILL CAUSE NO COPYING SINCE
		THE ONLY POINTER AT THE NEW STRING IS A
		TEMPORARY DESCRIPTOR CREATED BY "FRMEVL" WHICH WILL
		GO AWAY AS SOON AS THE ASSIGNMENT IS DONE.
		IT IS THE NATURE OF GARBAGE COLLECTION THAT
		DISALLOWS HAVING TWO STRING DESCRIPTORS POINT TO THE SAME
		AREA IN STRING SPACE. STRING FUNCTIONS AND OPERATORS
		MUST PROCEED AS FOLLOWS:
			1) FIGURE OUT THE LENGTH OF THEIR RESULT.

			2) CALL "GETSPA" TO FIND SPACE FOR THEIR
			RESULT. THE ARGUMENTS TO THE FUNCTION
			OR OPERATOR MAY CHANGE SINCE GARBAGE COLLECTION
			MAY BE INVOKED. THE ONLY THING THAT CAN
			BE SAVED DURING THE CALL TO "GETSPA" IS A POINTER
			TO THE DESCRIPTORS OF THE ARGUMENTS.
			3) CONSTRUCT THE RESULT DESCRIPTOR IN "DSCTMP".
			"GETSPA" RETURNS THE LOCATION OF THE AVAILABLE
			SPACE.
			4) CREATE THE NEW VALUE BY COPYING PARTS
			OF THE ARGUMENTS OR WHATEVER.
			5) FREE UP THE ARGUMENTS BY CALLING "FRETMP".
			6) JUMP TO "PUTNEW" TO GET THE DESCRIPTOR IN
			"DSCTMP" TRANSFERRED INTO A NEW STRING TEMPORARY.

		THE REASON FOR STRING TEMPORARIES IS THAT GARBAGE
		COLLECTION HAS TO KNOW ABOUT ALL ACTIVE STRING DESCRIPTORS
		SO IT KNOWS WHAT IS AND ISN'T IN USE. STRING TEMPORARIES ARE
		USED TO STORE THE DESCRIPTORS OF STRING EXPRESSIONS.
		
		INSTEAD OF HAVING AN ACTUAL VALUE STORED IN THE
		FAC, AND HAVING THE VALUE OF A TEMPORARY RESULT
		BEING SAVED ON THE STACK, AS HAPPENS WITH NUMERIC
		VARIABLES, STRINGS HAVE THE POINTER TO A STRING DESCRIPTOR
		STORED IN THE FAC, AND IT IS THIS POINTER
		THAT GETS SAVED ON THE STACK BY FORMULA EVALUATION.
		STRING FUNCTIONS CANNOT FREE THEIR ARGUMENTS UP RIGHT
		AWAY SINCE "GETSPA" MAY FORCE
		GARBAGE COLLECTION AND THE ARGUMENT STRINGS
		MAY BE OVER-WRITTEN SINCE GARBAGE COLLECTION
		WILL NOT BE ABLE TO FIND AN ACTIVE POINTER TO
		THEM. FUNCTION AND OPERATOR RESULTS ARE BUILT IN
		"DSCTMP" SINCE STRING TEMPORARIES ARE ALLOCATED
		(PUTNEW) AND DEALLOCATED (FRETMP) IN A FIFO ORDERING
		(I.E. A STACK) SO THE NEW TEMPORARY CANNOT
		BE SET UP UNTIL THE OLD ONE(S) ARE FREED. TRYING
		TO BUILD A RESULT IN A TEMPORARY AFTER
		FREEING UP THE ARGUMENT TEMPORARIES COULD RESULT
		IN ONE OF THE ARGUMENT TEMPORARIES BEING OVERWRITTEN
		TOO SOON BY THE NEW RESULT.

		STRING SPACE IS ALLOCATED AT THE VERY TOP
		OF MEMORY. "MEMSIZ" POINTS BEYOND THE LAST LOCATION OF
		STRING SPACE. STRINGS ARE STORED IN HIGH LOCATIONS
		FIRST. WHENEVER STRING SPACE IS ALLOCATED (GETSPA).
		[FRETOP], WHICH IS INITIALIZED TO [MEMSIZ], IS UPDATED
		TO GIVE THE HIGHEST LOCATION IN STRING SPACE
		THAT IS NOT IN USE. THE RESULT IS THAT
		[FRETOP] GETS SMALLER AND SMALLER, UNTIL SOME
		ALLOCATION WOULD MAKE [FRETOP] LESS THAN OR EQUAL TO
		[STREND]. THIS MEANS STRING SPACE HAS RUN INTO THE
		THE ARRAYS AND THAT GARBAGE COLLECTION MUST BE CALLED.

		GARBAGE COLLECTION:
			0. [MINPTR]=[STREND] [FRETOP]=[MEMSIZ]
			1. [REMMIN]=0
			2. FOR EACH STRING DESCRIPTOR
			(TEMPORARIES, SIMPLE STRINGS, STRING ARRAYS)
			IF THE STRING IS NOT NULL AND ITS POINTER IS
			.GT.MINPTR AND .LT.FRETOP,
			[MINPTR]=THIS STRING DESCRIPTOR'S POINTER,
			[REMMIN]=POINTER AT THIS STRING DESCRIPTOR.
			END.
			3. IF REMMIN.NE.0 (WE FOUND AN UNCOLLECTED STRING),
			BLOCK TRANSFER THE STRING DATA POINTED
			TO IN THE STRING DESCRIPTOR POINTED TO BY "REMMIN"
			SO THAT THE LAST BYTE OF STRING DATA IS AT
			[FRETOP]. UPDATE [FRETOP] SO THAT IT
			POINTS TO THE LOCATION JUST BELOW THE ONE
			THE STRING DATA WAS MOVED INTO. UPDATE
			THE POINTER IN THE DESCRIPTOR SO IT POINTS
			TO THE NEW LOCATION OF THE STRING DATA.
			GO TO STEP 1.

		AFTER CALLING GARBAGE COLLECTION "GETSPA" AGAIN CHECKS
		TO SEE IF [ACCA] CHARACTERS ARE AVAILABLE BETWEEN
		[STREND] AND [FRETOP]; IF NOT, AN "OUT OF STRING"
		ERROR IS INVOKED.

	MATH PACKAGE
		THE MATH PACKAGE CONTAINS FLOATING INPUT (FIN),
		FLOATING OUTPUT (FOUT), FLOATING COMPARE (FCOMP)
		... AND ALL THE NUMERIC OPERATORS AND FUNCTIONS.
		THE FORMATS, CONVENTIONS AND ENTRY POINTS ARE ALL
		DESCRIBED IN THE MATH PACKAGE ITSELF.

	INIT -- THE INITIALIZATION ROUTINE
		THE AMOUNT OF MEMORY,
		TERMINAL WIDTH, AND WHICH FUNCTIONS TO BE RETAINED
		ARE ASCERTAINED FROM THE USER. A ZERO IS PUT DOWN
		AT THE FIRST LOCATION NOT USED BY THE MATH-PACKAGE
		AND [TXTTAB] IS SET UP TO POINT AT THE NEXT LOCATION.
		THIS DETERMINES WHERE PROGRAM STORAGE WILL START.
		SPECIAL CHECKS ARE MADE TO MAKE SURE
		ALL QUESTIONS IN "INIT" ARE ANSWERED REASONABLY, SINCE
		ONCE "INIT" FINISHES, THE LOCATIONS IT USES ARE
		USED FOR PROGRAM STORAGE. THE LAST THING "INIT" DOES IS
		CHANGE LOCATION ZERO TO BE A JUMP TO "READY" INSTEAD
		OF "INIT". ONCE THIS IS DONE THERE IS NO WAY TO RESTART
		"INIT".
HIGH LOCATIONS

*
PAGE
