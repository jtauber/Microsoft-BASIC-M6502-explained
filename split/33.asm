SUBTTL	FLOATING MULTIPLICATION AND DIVISION.
	;MULTIPLICATION		FAC:=ARG*FAC.
FMULT:	JSR	CONUPK		;UNPACK THE CONSTANT INTO ARG FOR USE.
FMULTT: JEQ	MULTRT		;IF FAC=0, RETURN. FAC IS SET.
	JSR	MULDIV		;FIX UP THE EXPONENTS.
	LDAI	0		;TO CLEAR RESULT.
	STA	RESHO
IFN	ADDPRC,<
	STA	RESMOH>
	STA	RESMO
	STA	RESLO
	LDA	FACOV
	JSR	MLTPLY
	LDA	FACLO		;MLTPLY ARG BY FACLO.
	JSR	MLTPLY
	LDA	FACMO		;MLTPLY ARG BY FACMO.
	JSR	MLTPLY
IFN	ADDPRC,<
	LDA	FACMOH
	JSR	MLTPLY>
	LDA	FACHO		;MLTPLY ARG BY FACHO.
	JSR	MLTPL1
	JMP	MOVFR		;MOVE RESULT INTO FAC,
				;NORMALIZE RESULT, AND RETURN.
MLTPLY: JEQ	MULSHF		;SHIFT RESULT RIGHT 1 BYTE.
MLTPL1: LSR	A,
	ORAI	200
MLTPL2: TAY
	BCC	MLTPL3		;IT MULT BIT=0, JUST SHIFT.
	CLC
	LDA	RESLO
	ADC	ARGLO
	STA	RESLO
	LDA	RESMO
	ADC	ARGMO
	STA	RESMO
IFN	ADDPRC,<
	LDA	RESMOH
	ADC	ARGMOH
	STA	RESMOH>
	LDA	RESHO
	ADC	ARGHO
	STA	RESHO
MLTPL3: ROR	RESHO
IFN	ADDPRC,<
	ROR	RESMOH>
	ROR	RESMO
	ROR	RESLO
	ROR	FACOV		;SAVE FOR ROUNDING.
	TYA
	LSR	A,		;CLEAR MSB SO WE GET A CLOSER TO 0.
	BNE	MLTPL2		;SLOW AS A TURTLE !
MULTRT: RTS

	;ROUTINE TO UNPACK MEMORY INTO ARG.
CONUPK: STWD	INDEX1
	LDYI	3+ADDPRC
	LDADY	INDEX1
	STA	ARGLO
	DEY
	LDADY	INDEX1
	STA	ARGMO
	DEY
IFN	ADDPRC,<
	LDADY	INDEX1
	STA	ARGMOH
	DEY>
	LDADY	INDEX1
	STA	ARGSGN
	EOR	FACSGN
	STA	ARISGN
	LDA	ARGSGN
	ORAI	200
	STA	ARGHO
	DEY
	LDADY	INDEX1
	STA	ARGEXP
	LDA	FACEXP		;SET CODES OF FACEXP.
	RTS

	;CHECK SPECIAL CASES AND ADD EXPONENTS FOR FMULT, FDIV.
MULDIV: LDA	ARGEXP		;EXP OF ARG=0?
MLDEXP: BEQ	ZEREMV		;SO WE GET ZERO EXPONENT.
	CLC
	ADC	FACEXP		;RESULT IS IN ACCA.
	BCC	TRYOFF		;FIND [C] XOR [N].
	BMI	GOOVER		;OVERFLOW IF BITS MATCH.
	CLC
	SKIP2
TRYOFF: BPL	ZEREMV		;UNDERFLOW.
	ADCI	200		;ADD BIAS.
	STA	FACEXP
	JEQ	ZEROML		;ZERO THE REST OF IT.
	LDA	ARISGN
	STA	FACSGN		;ARISGN IS RESULT'S SIGN.
	RTS			;DONE.
MLDVEX: LDA	FACSGN		;GET SIGN.
	EORI	377		;COMPLEMENT IT.
	BMI	GOOVER
ZEREMV: PLA			;GET ADDR OFF STACK.
	PLA	
	JMP	ZEROFC		;UNDERFLOW.
GOOVER: JMP	OVERR		;OVERFLOW.

	;MULTIPLY FAC BY 10.
MUL10:	JSR	MOVAF		;COPY FAC INTO ARG.
	TAX
	BEQ	MUL10R		;IF [FAC]=0, GOT ANSWER.
	CLC
	ADCI	2		;AUGMENT EXP BY 2.
	BCS	GOOVER		;OVERFLOW.
FINML6: LDXI	0
	STX	ARISGN		;SIGNS ARE SAME.
	JSR	FADDC		;ADD TOGETHER.
	INC	FACEXP		;MULTIPLY BY TWO.
	BEQ	GOOVER		;OVERFLOW.
MUL10R: RTS

	; DIVIDE FAC BY 10.
TENZC:	204
	040
	000
	000
IFN	ADDPRC,<0>
DIV10:	JSR	MOVAF		;MOVE FAC TO ARG.
	LDWDI	TENZC		;POINT TO CONSTANT OF 10.0
	LDXI	0		;SIGNS ARE BOTH POSITIVE.
FDIVF:	STX	ARISGN
	JSR	MOVFM		;PUT IT INTO FAC.
	JMP	FDIVT		;SKIP OVER NEXT TWO BYTES.
FDIV:	JSR	CONUPK		;UNPACK CONSTANT.
FDIVT:	BEQ	DV0ERR		;CAN'T DIVIDE BY ZERO !
				;(NOT ENOUGH ROOM TO STORE RESULT.)
	JSR	ROUND		;TAKE FACOV INTO ACCT IN FAC.
	LDAI	0		;NEGATE FACEXP.
	SEC
	SBC	FACEXP
	STA	FACEXP
	JSR	MULDIV		;FIX UP EXPONENTS.
	INC	FACEXP		;SCALE IT RIGHT.
	BEQ	GOOVER		;OVERFLOW.
	LDXI	^D256-3-ADDPRC	;SETUP PROCEDURE.
	LDAI	1
DIVIDE:				;THIS IS THE BEST CODE IN THE WHOLE PILE.
	LDY	ARGHO		;SEE WHAT RELATION HOLDS.
	CPY	FACHO
	BNE	SAVQUO		;[C]=0,1. N(C=0)=0.
IFN	ADDPRC,<
	LDY	ARGMOH
	CPY	FACMOH
	BNE	SAVQUO>
	LDY	ARGMO
	CPY	FACMO
	BNE	SAVQUO
	LDY	ARGLO
	CPY	FACLO
SAVQUO: PHP
	ROL	A,		;SAVE RESULT.
	BCC	QSHFT		;IF NOT DONE, CONTINUE.
	INX
	STA	RESLO,X
	BEQ	LD100
	BPL	DIVNRM		;NOTE THIS REQ 1 MO RAM THEN NECESS.
	LDAI	1
QSHFT:	PLP			;RETURN CONDITION CODES.
	BCS	DIVSUB		;FAC .LE. ARG.
SHFARG: ASL	ARGLO		;SHIFT ARG ONE PLACE LEFT.
	ROL	ARGMO
IFN	ADDPRC,<
	ROL	ARGMOH>
	ROL	ARGHO
	BCS	SAVQUO		;SAVE A RESULT OF ONE FOR THIS POSITION
				;AND DIVIDE.
	BMI	DIVIDE		;IF MSB ON, GO DECIDE WHETHER TO SUB.
	BPL	SAVQUO
DIVSUB: TAY			;NOTICE C MUST BE ON HERE.
	LDA	ARGLO
	SBC	FACLO
	STA	ARGLO
	LDA	ARGMO
	SBC	FACMO
	STA	ARGMO
IFN	ADDPRC,<
	LDA	ARGMOH
	SBC	FACMOH
	STA	ARGMOH>
	LDA	ARGHO
	SBC	FACHO
	STA	ARGHO
	TYA
	JMP	SHFARG
LD100:	LDAI	100		;ONLY WANT TWO MORE BITS.
	BNE	QSHFT		;ALWAYS BRANCHES.
DIVNRM: REPEAT	6,<ASL	A>	;GET LAST TWO BITS INTO MSB AND B6.
	STA	FACOV
	PLP			;TO GET GARBAGE OFF STACK.
	JMP	MOVFR		;MOVE RESULT INTO FAC, THEN
				;NORMALIZE RESULT AND RETURN.
DV0ERR: LDXI	ERRDV0
	JMP	ERROR
PAGE
