SUBTTL	INPUT AND READ CODE.
;
; HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS
; IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN.
; FOR "READ" WE GIVE A SYNTAX ERROR AT THE DATA LINE.
;
TRMNOK: LDA	INPFLG
	BEQ	TRMNO1		;IF INPUT TRY AGAIN.
IFN	GETCMD,<
	BMI	GETDTL
	LDYI	255		;MAKE IT LOOK DIRECT.
	BNEA	STCURL		;ALWAYS GOES.
GETDTL:>
	LDWD	DATLIN		;GET DATA LINE NUMBER.
STCURL: STWD	CURLIN		;MAKE IT CURRENT LINE.
SNERR4: JMP	SNERR
TRMNO1:
IFN	EXTIO,<
	LDA	CHANNL		;IF NOT TERMINAL, GIVE BAD DATA.
	BEQ	DOAGIN
	LDXI	ERRBD
	JMP	ERROR>
DOAGIN: LDWDI	TRYAGN
	JSR	STROUT		;PRINT "?REDO FROM START".
	LDWD	OLDTXT		;POINT AT START
	STWD	TXTPTR		;OF THIS CURRENT LINE.
	RTS			;GO TO "NEWSTT".
IFN	GETCMD,<
GET:	JSR	ERRDIR		;DIRECT IS NOT OK.
IFN	EXTIO,<
	CMPI	"#"		;SEE IF "GET#".
	BNE	GETTTY		;NO, JUST GET TTY INPUT.
	JSR	CHRGET		;MOVE UP TO NEXT BYTE.
	JSR	GETBYT		;GET CHANNEL INTO X
	SYNCHK	44		;COMMA?
	JSR	CQOIN		;GET CHANNEL OPEN FOR INPUT.
	STX	CHANNL>
GETTTY: LDXYI	BUF+1		;POINT TO 0.
IFN	BUFPAG,<
	LDAI	0		;TO STUFF AND TO POINT.
	STA	BUF+1>
IFE	BUFPAG,<
	STY	BUF+1>		;ZERO IT.
	LDAI	64		;TURN ON V-BIT.
	JSR	INPCO1		;DO THE GET.
IFN	EXTIO,<
	LDX	CHANNL
	BNE	IORELE>		;RELEASE.
	RTS>

IFN	EXTIO,<
INPUTN: JSR	GETBYT		;GET CHANNEL NUMBER.
	SYNCHK	44		;A COMMA?
	JSR	CQOIN		;GO WHERE COMMODORE CHECKS IN OPEN.
	STX	CHANNL
	JSR	NOTQTI		;DO INPUT TO VARIABLES.
IODONE: LDA	CHANNL		;RELEASE CHANNEL.
IORELE: JSR	CQCCHN
	LDXI	0		;RESET CHANNEL TO TERMINAL.
	STX	CHANNL
	RTS>
INPUT:	IFN	REALIO,<
	LSR	CNTWFL>		;BE TALKATIVE.
	CMPI	34		;A QUOTE?
	BNE	NOTQTI		;NO MESSAGE.
	JSR	STRTXT		;LITERALIZE THE STRING IN TEXT
	SYNCHK	59		;MUST END WITH SEMICOLON.
	JSR	STRPRT		;PRINT IT OUT.
NOTQTI: JSR	ERRDIR		;USE COMMON ROUTINE SINCE DEF DIRECT
	LDAI	44		;GET COMMA.
	STA	BUF-1
				;IS ALSO ILLEGAL.
GETAGN: JSR	QINLIN		;TYPE "?" AND INPUT A LINE OF TEXT.
IFN	EXTIO,<
	LDA	CHANNL
	BEQ	BUFFUL
	LDA	CQSTAT		;GET STATUS BYTE.
	ANDI	2
	BEQ	BUFFUL		;A-OK.
	JSR	IODONE		;BAD. CLOSE CHANNEL.
	JMP	DATA		;SKIP REST OF INPUT.
BUFFUL:>
	LDA	BUF		;ANYTHING INPUT?
	BNE	INPCON		;YES, CONTINUE.
IFN	EXTIO,<
	LDA	CHANNL		;BLANK LINE MEANS GET ANOTHER.
	BNE	GETAGN>		;IF NOT TERMINAL.
	CLC			;MAKE SURE DONT PRINT BREAK
	JMP	STPEND		;NO, STOP.
QINLIN:
IFN	EXTIO,<
	LDA	CHANNL
	BNE	GINLIN>
	JSR	OUTQST
	JSR	OUTSPC
GINLIN: JMP	INLIN
READ:	LDXY	DATPTR		;GET LAST DATA LOCATION.
	XWD	^O1000,^O251	;LDAI TYA TO MAKE IT NONZERO.
IFE	BUFPAG,<
INPCON: >
	TYA
IFN	BUFPAG,<
	SKIP2
INPCON: LDAI	0>		;SET FLAG THAT THIS IS INPUT
INPCO1: STA	INPFLG		;STORE THE FLAG.
;
; IN THE PROCESSING OF DATA AND READ STATEMENTS:
; ONE POINTER POINTS TO THE DATA (IE, THE NUMBERS BEING FETCHED)
; AND ANOTHER POINTS TO THE LIST OF VARIABLES.
;
; THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A
; TERMINATOR -- A , : OR END-OF-LINE.
;
; AT THIS POINT TXTPTR POINTS TO LIST OF VARIABLES AND
; [Y,X] POINTS TO DATA OR INPUT LINE.
;
	STXY	INPPTR
INLOOP: JSR	PTRGET		;READ VARIABLE LIST.
	STWD	FORPNT		;SAVE POINTER FOR "LET" STRING STUFFING.
				;RETURNS PNTR TOP VAR IN VARPNT.
	LDWD	TXTPTR		;SAVE TEXT PNTR.
	STWD	VARTXT
	LDXY	INPPTR
	STXY	TXTPTR
	JSR	CHRGOT		;GET IT AND SET Z IF TERM.
	BNE	DATBK1
	BIT	INPFLG
IFN	GETCMD,<
	BVC	QDATA
	JSR	CZGETL		;DON'T WANT INCHR. JUST ONE.
IFE	REALIO-4,<
	ANDI	127>
	STA	BUF		;MAKE IT FIRST CHARACTER.
	LDXYI	<BUF-1>		;POINT JUST BEFORE IT.
IFE	BUFPAG,<
	BEQA	DATBK>
IFN	BUFPAG,<
	BNEA	DATBK>>		;GO PROCESS.
QDATA:	BMI	DATLOP		;SEARCH FOR ANOTHER DATA STATEMENT.
IFN	EXTIO,<
	LDA	CHANNL
	BNE	GETNTH>
	JSR	OUTQST
GETNTH: JSR	QINLIN		;GET ANOTHER LINE.
DATBK:	STXY	TXTPTR		;SET FOR "CHRGET".
DATBK1: JSR	CHRGET
	BIT	VALTYP		;GET VALUE TYPE.
	BPL	NUMINS		;INPUT A NUMBER IF NUMERIC.
IFN	GETCMD,<
	BIT	INPFLG		;GET?
	BVC	SETQUT		;NO, GO SET QUOTE.
	INX
	STX	TXTPTR
	LDAI	0		;ZERO TERMINATORS.
	STA	CHARAC
	BEQA	RESETC>
SETQUT: STA	CHARAC		;ASSUME QUOTED STRING.
	CMPI	34		;TERMINATORS OK?
	BEQ	NOWGET		;YES.
	LDAI	":"		;SET TERMINATORS TO ":" AND
	STA	CHARAC
	LDAI	44		;COMMA.
RESETC: CLC
NOWGET: STA	ENDCHR
	LDWD	TXTPTR
	ADCI	0		;C IS SET PROPERLY ABOVE.
	BCC	NOWGE1
	INY
NOWGE1: JSR	STRLT2		;MAKE A STRING DESCRIPTOR FOR THE VALUE
				;AND COPY IF NECESSARY.
	JSR	ST2TXT		;SET TEXT POINTER.
	JSR	INPCOM		;DO ASSIGNMENT.
	JMP	STRDN2
NUMINS: JSR	FIN
IFE	INTPRC,<
	JSR	MOVVF>
IFN	INTPRC,<
	LDA	INTFLG		;SET CODES ON FLAG.
	JSR	QINTGR>		;GO DECIDE ON FLOAT.
STRDN2: JSR	CHRGOT		;READ LAST CHARACTER.
	BEQ	TRMOK		;":" OR EOL IS OK.
	CMPI	44		;A COMMA?
	JNE	TRMNOK
TRMOK:	LDWD	TXTPTR
	STWD	INPPTR		;SAVE FOR MORE READS.
	LDWD	VARTXT
	STWD	TXTPTR		;POINT TO VARIABLE LIST.
	JSR	CHRGOT		;LOOK AT LAST VARIABLE LIST CHARACTER.
	BEQ	VAREND		;THAT'S THE END OF THE LIST.
	JSR	CHKCOM		;NOT END. CHECK FOR COMMA.
	JMP	INLOOP
;
; SUBROUTINE TO FIND DATA
; THE SEARCH IS MADE BY USING THE EXECUTION CODE FOR DATA TO
; SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT
; IS COMPARED WITH "DATATK". EACH NEW LINE NUMBER
; IS STORED IN "DATLIN" SO THAT IF AN ERROR OCCURS
; WHILE READING DATA THE ERROR MESSAGE CAN GIVE THE LINE
; NUMBER OF THE ILL-FORMATTED DATA.
;
DATLOP: JSR	DATAN		;SKIP SOME TEXT.
	INY
	TAX			;END OF LINE?
	BNE	NOWLIN		;SHO AIN'T.
	LDXI	ERROD		;YES = "NO DATA" ERROR.
	INY
	LDADY	TXTPTR
	BEQ	ERRGO5
	INY
	LDADY	TXTPTR		;GET HIGH BYTE OF LINE NUMBER.
	STA	DATLIN
	INY
	LDADY	TXTPTR		;GET LOW BYTE.
	INY
	STA	DATLIN+1
NOWLIN: LDADY	TXTPTR		;HOW IS IT?
	TAX
	JSR	ADDON		;ADD [Y] TO [TXTPTR].
	CPXI	DATATK		;IS IT A "DATA" STATEMENT.
	BNE	DATLOP		;NOT QUITE RIGHT. KEEP LOOKING.
	JMP	DATBK1		;THIS IS THE ONE !
VAREND: LDWD	INPPTR		;PUT AWAY A NEW DATA PNTR MAYBE.
	LDX	INPFLG
	BPL	VARY0
	JMP	RESFIN
VARY0:	LDYI	0
	LDADY	INPPTR		;LAST DATA CHR COULD HAVE BEEN
				;COMMA OR COLON BUT SHOULD BE NULL.
	BEQ	INPRTS		;IT IS NULL.
IFN	EXTIO,<
	LDA	CHANNL		;IF NOT TERMINAL, NO TYPE.
	BNE	INPRTS>
	LDWDI	EXIGNT
	JMP	STROUT		;TYPE "?EXTRA IGNORED"
INPRTS: RTS			;DO NEXT STATEMENT.
EXIGNT: DT"?EXTRA IGNORED"
	ACRLF
	0
TRYAGN: DT"?REDO FROM START"
	ACRLF
	0
PAGE
